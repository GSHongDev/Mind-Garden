# C++入门学习笔记

## 1. C++简介
- C++的历史和发展
- C++的特点和优势
- C++的应用领域

## 2. C++与C的基本区别
- 头文件差异
- 输入输出方式
- 代码示例对比
  ```cpp
  // C语言方式
  #include<stdio.h>
  int main()
  {
      printf("hello world\n");
      return 0;
  }
  
  // C++方式
  #include<iostream>
  using namespace std;
  int main()
  {
      cout << "hello world" << endl;
      return 0;
  }
  ```

## 3. 命名空间（namespace）
- 命名空间的概念和作用
- 命名空间的定义
  ```cpp
  namespace bit1
  {
      int rand = 0;
      int Add(int left, int right)
      {
          return left + right;
      }
  }
  ```
- 命名空间的使用方式
  - 作用域解析运算符::
  - using namespace 指令
  - using声明
- 命名冲突问题及解决方案
- 嵌套命名空间
  ```cpp
  namespace bit
  {
      namespace zs
      {
          void Push() {}
      }
  }
  ```
- 全局变量与局部变量作用域
  ```cpp
  int global = 100; // 全局变量
  
  int main()
  {
      int local = 200; // 局部变量
      printf("global = %d\n", global);
      printf("local = %d\n", local);
      return 0;
  }
  ```
  - 全局变量：在函数外部定义，作用域为整个程序
  - 局部变量：在函数内部定义，作用域为所在函数体

## 4. C++的输入输出
- cout输出流
  - 自动类型识别
  - 连续输出
- cin输入流
- endl操纵符
- C++与C的输入输出对比
  ```cpp
  // C++方式
  double d = 1.11111111;
  cout << d << endl;
  
  // C方式
  printf("%.2lf\n", d);
  ```

## 5. 函数默认参数
- 默认参数的概念和作用
- 默认参数的定义和使用规则
  ```cpp
  void Func(int a = 10, int b = 20, int c = 30)
  {
      cout << "a = " << a << endl;
      cout << "b = " << b << endl;
      cout << "c = " << c << endl;
  }
  ```
- 默认参数的注意事项
  - 从右向左连续设置
  - 不能在声明和定义中同时指定默认值
- 默认参数的实际应用场景
  ```cpp
  void StackInit(struct Stack* ps, int n = 4);
  ```

## 6. 函数重载
- 函数重载的概念
- C++支持函数重载的原理（函数名修饰）
- 函数重载的条件
  - 参数类型不同
  - 参数个数不同
  - 参数顺序不同
- 函数重载的示例
  ```cpp
  // 参数类型不同
  int Add(int left, int right);
  double Add(double left, double right);
  
  // 参数顺序不同
  void f(int a, char b);
  void f(char b, int a);
  ```
- C语言不支持函数重载的原因
- 函数重载的实际应用

## 7. 引用（Reference）
- 引用的基本概念（变量的别名）
- 引用的语法和初始化
  ```cpp
  int a = 10;
  int& ra = a; // 引用必须初始化
  ```
- 引用的特性
  - 必须初始化
  - 一旦引用一个实体，不能再引用其他实体
  - 引用的类型必须与引用实体的类型一致
- 引用的使用场景
  - 作为函数参数（替代指针）
    ```cpp
    void Swap(int& a, int& b)
    {
        int tmp = a;
        a = b;
        b = tmp;
    }
    ```
  - 作为函数返回值
    ```cpp
    int& func()
    {
        static int a = 0;
        return a;
    }
    ```
- 使用引用的注意事项
  - 不能返回局部变量的引用
  - 静态变量和全局变量可以安全地返回引用
- 引用与指针的区别
- 引用在提高代码效率中的应用
  ```cpp
  void TestFunc1(A a) {} // 值传递，拷贝开销大
  void TestFunc2(A& a) {} // 引用传递，效率高
  ```

## 8. 内联函数（Inline Function）
- 内联函数的概念和作用
- 内联函数的定义和使用
  ```cpp
  inline int Add(int a, int b)
  {
      return a + b;
  }
  ```
- 内联函数的原理（编译期展开）
- 内联函数与宏定义的比较
  - 宏定义的缺陷
    ```cpp
    #define ADD(a, b) ((a)+(b)) // 需要额外括号
    ```
  - 内联函数的优势
    - 类型安全检查
    - 遵循作用域规则
    - 调试支持
- 内联函数的使用建议
  - 函数体简洁（通常不超过10行）
  - 避免递归调用
  - 避免复杂的条件判断
- 内联函数的实际应用场景
- 宏定义的注意事项（与内联函数对比）
  ```cpp
  // 宏定义中运算符优先级问题示例
  #define ADD(a, b) (a + b) // 不使用额外括号的问题
  #define MUL(a, b) (a * b) // 不使用额外括号的问题
  
  // 正确的宏定义方式
  #define ADD(a, b) ((a) + (b)) // 使用额外括号避免优先级问题
  #define MUL(a, b) ((a) * (b)) // 使用额外括号避免优先级问题
  ```
  - 宏定义中必须注意运算符优先级，使用足够的括号
  - 宏定义不进行类型检查，可能导致潜在的类型错误
  - 宏定义不遵循正常的作用域规则
  - 宏定义在调试时难以跟踪，而内联函数可以正常调试

## 9. 常量与指针
- const修饰变量
  ```cpp
  const int a = 10; // a的值不能改变
  ```
- const与指针的结合
  - 指向常量的指针（不能通过指针修改所指对象的值）
    ```cpp
    const int* p1 = &a; // 或 int const* p1 = &a;
    ```
  - 常量指针（指针本身不能改变指向）
    ```cpp
    int* const p2 = &a;
    ```
  - 指向常量的常量指针
    ```cpp
    const int* const p3 = &a;
    ```
- const与引用的结合
  ```cpp
  const int& r = a; // 引用r不能修改a的值
  ```
- const在函数参数中的应用
  ```cpp
  void Print(const int& x) // 保护参数不被修改
  ```


## 10. auto关键字
- auto关键字的概念和作用（自动类型推导）
- auto的使用场景和语法
  ```cpp
  int i = 0;
  auto k = i; // k的类型自动推导为int
  auto p1 = &i; // p1的类型自动推导为int*
  auto* p2 = &i; // p2明确指定为指针类型
  auto& r = i; // r的类型自动推导为int&
  ```
- auto的使用注意事项
  - 必须初始化才能推导类型
  - 不能作为函数参数类型
  - 在连续声明中，所有变量必须推导为同一类型
- auto在简化代码中的应用
  ```cpp
  // 简化复杂类型声明
  std::map<std::string, std::string> dict;
  auto it = dict.begin(); // 替代冗长的类型声明
  ```
- auto与函数返回值的使用
  ```cpp
  auto f2()
  {
      auto ret = 1;
      return ret;
  }
  ```

## 11. 范围for循环
- 范围for循环的概念和作用（简化数组和容器的遍历）
- 范围for循环的语法格式
  ```cpp
  for (auto e : array) // e是数组元素的拷贝
  {
      // 处理e
  }
  ```
- 范围for循环的使用注意事项
  - 遍历的范围必须是确定的（不能用于数组传参后的遍历）
  - 如果要修改元素值，需要使用引用
  ```cpp
  for (auto& e : array) // e是数组元素的引用，可以修改原元素
  {
      e *= 2; // 修改原数组元素
  }
  ```
- 范围for循环与传统for循环的对比
  ```cpp
  // 传统for循环
  for (int i = 0; i < sizeof(array) / sizeof(array[0]); ++i)
      array[i] *= 2;
  
  // 范围for循环（更简洁）
  for (auto& e : array)
      e *= 2;
  ```

## 12. nullptr关键字
- nullptr的概念和作用（C++11引入的空指针常量）
- nullptr与NULL的区别
  ```cpp
  void f(int i) { cout << "f(int)" << endl; }
  void f(int* p) { cout << "f(int*)" << endl; }
  
  int main()
  {
      f(0); // 调用f(int)
      f(NULL); // 可能调用f(int)，取决于NULL的定义
      f(nullptr); // 调用f(int*)
      return 0;
  }
  ```
- nullptr的优势
  - 明确表示空指针类型，避免二义性
  - 与模板和重载函数配合使用更加准确
- nullptr的使用场景
  ```cpp
  int* p = nullptr; // 正确初始化空指针
  if (ptr == nullptr) // 检查指针是否为空
  {
      // 处理空指针情况
  }
  ```